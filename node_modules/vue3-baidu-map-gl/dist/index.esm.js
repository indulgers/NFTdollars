import { getCurrentInstance, onUnmounted, defineComponent, ref, computed, onMounted, provide, openBlock, createElementBlock, Fragment, createElementVNode, normalizeStyle, unref, renderSlot, toDisplayString, nextTick, watch, inject, mergeProps, onUpdated } from 'vue';

function mitt(n){return {all:n=n||new Map,on:function(t,e){var i=n.get(t);i?i.push(e):n.set(t,[e]);},off:function(t,e){var i=n.get(t);i&&(e?i.splice(i.indexOf(e)>>>0,1):n.set(t,[]));},emit:function(t,e){var i=n.get(t);i&&i.slice().map(function(n){n(e);}),(i=n.get("*"))&&i.slice().map(function(n){n(t,e);});}}}

const emitter = mitt();
function useBaseMapListener() {
    return {
        emit: emitter.emit,
        on: emitter.on,
        off: emitter.off
    };
}

function useLifeCycle() {
    const { uid, emit: VueEmit } = getCurrentInstance();
    const { on, emit, off } = useBaseMapListener();
    const eventKey = `__initd__${uid}`;
    on(eventKey, (instance) => {
        VueEmit('initd', instance);
    });
    onUnmounted(() => {
        VueEmit('unload');
        off(eventKey);
    });
    return {
        ready: (map, instance) => {
            emit(eventKey, {
                map,
                instance,
                BMapGL: window.BMapGL
            });
        }
    };
}

const BMapScriptLoaderWrapper = {};
function getScriptAsync({ key, src, addCalToWindow }) {
    if (!BMapScriptLoaderWrapper[key]) {
        BMapScriptLoaderWrapper[key] = new Promise((resolve, reject) => {
            const script = document.createElement('script');
            const cal = () => {
                resolve();
                window.document.body.removeChild(script);
            };
            if (addCalToWindow) {
                window[key] = cal;
            }
            else {
                script.onload = function () {
                    if (!this.readyState || this.readyState == 'loaded' || this.readyState == 'complete') {
                        script.onload = null;
                        cal();
                    }
                };
            }
            script.src = src;
            script.type = 'text/javascript';
            script.defer = true;
            script.onerror = reject;
            document.body.appendChild(script);
        });
    }
    return BMapScriptLoaderWrapper[key];
}

/** @format */
const DEFAULT_PLUGINS_SOURCE_LINK = {
    TrackAnimation: '//mapopen.bj.bcebos.com/github/BMapGLLib/TrackAnimation/src/TrackAnimation.min.js',
    Mapvgl: 'https://code.bdstatic.com/npm/mapvgl@1.0.0-beta.159/dist/mapvgl.min.js',
    Mapv: 'https://mapv.baidu.com/build/mapv.min.js',
    MapvThree: 'https://unpkg.com/mapv-three@1.0.1/dist/mapvthree.umd.js'
};
const pluginLoaderMap = {
    TrackAnimation: (customSourceLink) => getScriptAsync({
        src: customSourceLink || DEFAULT_PLUGINS_SOURCE_LINK['TrackAnimation'],
        addCalToWindow: false,
        key: 'trackAnimation'
    }),
    Mapvgl: (customSourceLink) => getScriptAsync({
        src: customSourceLink || DEFAULT_PLUGINS_SOURCE_LINK['Mapvgl'],
        addCalToWindow: false,
        key: 'Mapvgl'
    }),
    Mapv: (customSourceLink) => getScriptAsync({
        src: customSourceLink || DEFAULT_PLUGINS_SOURCE_LINK['Mapv'],
        addCalToWindow: false,
        key: 'Mapv'
    }),
    MapvThree: (customSourceLink) => getScriptAsync({
        src: customSourceLink || DEFAULT_PLUGINS_SOURCE_LINK['MapvThree'],
        addCalToWindow: false,
        key: 'MapvThree'
    })
};
function initPlugins(plugins, customPluginSourceLink = {}) {
    // 都处理成 () => promise
    const pluginsLoaders = [...new Set(plugins)].reduce((pluginsLoaderArr, pluginsKey) => {
        let plugin;
        if (typeof pluginsKey === 'string' && (plugin = pluginLoaderMap[pluginsKey])) {
            pluginsLoaderArr.push(plugin(customPluginSourceLink[pluginsKey]));
        }
        else if (typeof pluginsKey === 'function') {
            pluginsLoaderArr.push(pluginsKey());
        }
        return pluginsLoaderArr;
    }, []);
    // 加载插件
    return Promise.all(pluginsLoaders);
}

function bindEvents(props, VueEmit, instance) {
    for (const key of Object.keys(props)) {
        if (/^on/.test(key) && props[key]) {
            const _key = key.replace(/^on/, '').toLocaleLowerCase();
            instance.addEventListener(_key, (e) => {
                var _a, _b;
                e.preventDefault = e.preventDefault || ((_a = e.domEvent) === null || _a === void 0 ? void 0 : _a.preventDefault.bind(e.domEvent));
                e.stopPropagation = e.stopPropagation || ((_b = e.domEvent) === null || _b === void 0 ? void 0 : _b.stopPropagation.bind(e.domEvent));
                VueEmit(_key, e);
            });
        }
    }
}

/**
 * watch 回调辅助前置判断
 * @param cal watch 处理函数
 * @returns (nv: T, ov: T) => void
 */
function callWhenDifferentValue(cal) {
    return (nv, ov) => {
        if (nv === ov || (nv !== ov && JSON.stringify(nv) !== JSON.stringify(ov)))
            cal(nv);
    };
}

/**
 * warn 抛出警告
 * @internal
 * @param {string} 警告内容
 */
function warn(text) {
    console.warn(`[Vue3 BaiduMap GL] ${text}`);
}
function error(text) {
    console.error(`[Vue3 BaiduMap GL] ${text}`);
}

/**
 *
 * @param value 判断是否是字符串的值
 * @returns
 */
function isString(value) {
    return Object.prototype.toString.call(value) === '[object String]';
}
/**
 *
 * @param value 判断是否是字符串的值
 * @returns
 */
function isArray(value) {
    return Object.prototype.toString.call(value) === '[object Array]';
}
/**
 * 判断某个值是否是 undefined 或者 null
 * @param v 需要判断的值
 * @returns
 */
function isDef(v) {
    return v !== undefined && v !== null;
}

var DistrictType;
(function (DistrictType) {
    DistrictType[DistrictType["PROVINCE"] = 0] = "PROVINCE";
    DistrictType[DistrictType["CITY"] = 1] = "CITY";
    DistrictType[DistrictType["AREA"] = 2] = "AREA";
})(DistrictType || (DistrictType = {}));

const _hoisted_1$3 = { style: { "color": "#999", "position": "absolute", "top": "50%", "left": "50%", "transform": "translate(-50%, -50%)" } };
const __default__$l = {
    name: 'BMap'
};
var script$l = /*#__PURE__*/ defineComponent(Object.assign(Object.assign({}, __default__$l), { props: {
        ak: null,
        width: { default: '100%' },
        height: { default: '550px' },
        center: { default: () => ({ lat: 39.915185, lng: 116.403901 }) },
        mapType: { default: 'BMAP_NORMAL_MAP' },
        zoom: { default: 14 },
        heading: { default: 0 },
        tilt: { default: 0 },
        minZoom: { default: 0 },
        maxZoom: { default: 21 },
        noAnimation: { type: Boolean, default: false },
        mapStyleId: null,
        mapStyleJson: null,
        showControls: { type: Boolean, default: false },
        plugins: null,
        pluginsSourceLink: null,
        displayOptions: null,
        restrictCenter: { type: Boolean, default: true },
        enableTraffic: { type: Boolean, default: false },
        enableDragging: { type: Boolean, default: true },
        enableInertialDragging: { type: Boolean, default: true },
        enableScrollWheelZoom: { type: Boolean, default: false },
        enableContinuousZoom: { type: Boolean, default: true },
        enableResizeOnCenter: { type: Boolean, default: true },
        enableDoubleClickZoom: { type: Boolean, default: false },
        enableKeyboard: { type: Boolean, default: true },
        enablePinchToZoom: { type: Boolean, default: true },
        enableAutoResize: { type: Boolean, default: true },
        onClick: null,
        onDblclick: null,
        onRightclick: null,
        onRightdblclick: null,
        onMaptypechange: null,
        onMousemove: null,
        onMouseover: null,
        onMouseout: null,
        onMovestart: null,
        onMoving: null,
        onMoveend: null,
        onZoomstart: null,
        onZoomend: null,
        onAddoverlay: null,
        onAddcontrol: null,
        onRemovecontrol: null,
        onRemoveoverlay: null,
        onClearoverlays: null,
        onDragstart: null,
        onDragging: null,
        onDragend: null,
        onAddtilelayer: null,
        onRemovetilelayer: null,
        onLoad: null,
        onResize: null,
        onHotspotclick: null,
        onHotspotover: null,
        onHotspotout: null,
        onTilesloaded: null,
        onTouchstart: null,
        onTouchmove: null,
        onTouchend: null,
        onLongpress: null
    }, emits: [
        'initd',
        'unload',
        'pluginReady',
        'click',
        'dblclick',
        'rightclick',
        'rightdblclick',
        'maptypechange',
        'mousemove',
        'mouseover',
        'mouseout',
        'movestart',
        'moving',
        'moveend',
        'zoomstart',
        'zoomend',
        'addoverlay',
        'addcontrol',
        'removecontrol',
        'removeoverlay',
        'clearoverlays',
        'dragstart',
        'dragging',
        'dragend',
        'addtilelayer',
        'removetilelayer',
        'load',
        'resize',
        'hotspotclick',
        'hotspotover',
        'hotspotout',
        'tilesloaded',
        'touchstart',
        'touchmove',
        'touchend',
        'longpress'
    ], setup(__props, { expose, emit: vueEmits }) {
        const props = __props;
        const mapContainer = ref();
        let map = null;
        // 是否初始化
        let initd = ref(false);
        // 地图初始化的发布
        const { ready } = useLifeCycle();
        const { uid, proxy } = getCurrentInstance();
        const width = computed(() => (isString(props.width) ? props.width : `${props.width}px`));
        const height = computed(() => (isString(props.height) ? props.height : `${props.height}px`));
        const ak = props.ak || proxy.$baiduMapAk;
        const plugins = props.plugins && proxy.$baiduMapPlugins
            ? Object.assign(proxy.$baiduMapPlugins, props.plugins)
            : props.plugins || proxy.$baiduMapPlugins;
        const pluginsSourceLink = props.pluginsSourceLink && proxy.$baiduMapPluginsSourceLink
            ? Object.assign(proxy.$baiduMapPluginsSourceLink, props.pluginsSourceLink)
            : props.pluginsSourceLink || proxy.$baiduMapPluginsSourceLink || {};
        if (!ak)
            error('missing required props: ak');
        const scriptKey = `_initBMap${ak}`;
        // 初始化地图
        function init() {
            getScriptAsync({
                src: `//api.map.baidu.com/api?type=webgl&v=1.0&ak=${ak}&callback=${scriptKey}`,
                addCalToWindow: true,
                key: scriptKey
            })
                .then(() => {
                const { restrictCenter, minZoom, maxZoom, mapType, enableAutoResize, showControls, center } = props;
                if (!mapContainer.value)
                    return;
                map = new BMapGL.Map(mapContainer.value, {
                    restrictCenter,
                    minZoom,
                    maxZoom,
                    mapType: window[mapType],
                    enableAutoResize,
                    showControls
                });
                setCenterAndZoom(center);
                initMapOptions();
                initCustomStyle();
                startWatchProps();
                bindEvents(props, vueEmits, map);
                if (!initd.value) {
                    initd.value = true;
                    nextTick(() => ready(map, map));
                    if (plugins) {
                        initPlugins(plugins, pluginsSourceLink)
                            .then(() => {
                            vueEmits('pluginReady', map);
                        })
                            .catch((err) => {
                            error('plugins load error: ' + err);
                        });
                    }
                }
            })
                .catch(error);
        }
        // 个性化地图
        function initCustomStyle() {
            if (props.mapStyleId) {
                map.setMapStyleV2({
                    styleId: props.mapStyleId
                });
                return;
            }
            else if (props.mapStyleJson) {
                map.setMapStyleV2({
                    styleJson: props.mapStyleJson
                });
            }
        }
        // 监听props变化
        function startWatchProps() {
            watch(() => props.zoom, setZoom);
            watch(() => props.tilt, setTilt);
            watch(() => props.heading, setHeading);
            watch(() => props.center, callWhenDifferentValue(setCenterAndZoom), {
                deep: true
            });
            watch(() => props.mapStyleId, initCustomStyle);
            watch(() => props.mapStyleJson, callWhenDifferentValue(initCustomStyle), {
                deep: true
            });
            watch(() => props.displayOptions, callWhenDifferentValue(setDisplayOptions), {
                deep: true
            });
            watch(() => props.mapType, setMapType);
            watch(() => props.enableTraffic, setTraffic);
            watch(() => props.enableDragging, setDragging);
            watch(() => props.enableInertialDragging, setInertialDragging);
            watch(() => props.enableScrollWheelZoom, setScrollWheelZoom);
            watch(() => props.enableContinuousZoom, setContinuousZoom);
            watch(() => props.enableResizeOnCenter, setResizeOnCenter);
            watch(() => props.enableDoubleClickZoom, setDoubleClickZoom);
            watch(() => props.enableKeyboard, setKeyboard);
            watch(() => props.enablePinchToZoom, setPinchToZoom);
            watch(() => props.enableAutoResize, setAutoResize);
        }
        // 设置地图属性
        function initMapOptions() {
            const { enableDragging, enableInertialDragging, enableScrollWheelZoom, enableContinuousZoom, enableResizeOnCenter, enableDoubleClickZoom, enableKeyboard, enablePinchToZoom, enableAutoResize, enableTraffic, displayOptions, mapType, zoom, tilt, heading } = props;
            setZoom(zoom);
            setTilt(tilt);
            setTraffic(enableTraffic);
            setHeading(heading);
            setMapType(mapType);
            setKeyboard(enableKeyboard);
            setDragging(enableDragging);
            setAutoResize(enableAutoResize);
            setPinchToZoom(enablePinchToZoom);
            setContinuousZoom(enableContinuousZoom);
            setResizeOnCenter(enableResizeOnCenter);
            setDoubleClickZoom(enableDoubleClickZoom);
            setScrollWheelZoom(enableScrollWheelZoom);
            setInertialDragging(enableInertialDragging);
            setDisplayOptions(displayOptions);
        }
        // 生产一个地理位置坐标点
        function genPoint(lng, lat) {
            return new BMapGL.Point(lng, lat);
        }
        /**
         * 设置是否显示路况图层
         */
        function setTraffic(enableTraffic) {
            enableTraffic ? map.setTrafficOn() : map.setTrafficOff();
        }
        /**
         * 设置中心点和缩放级别
         */
        function setCenterAndZoom(center) {
            if (typeof center === 'string') {
                map.centerAndZoom(center, props.zoom);
            }
            else {
                map.centerAndZoom(genPoint(center.lng, center.lat), props.zoom);
            }
        }
        /**
         * 设置地图自定义属性
         */
        function setDisplayOptions(displayOptions) {
            map.setDisplayOptions(displayOptions || {});
        }
        /**
         * 设置缩放级别
         */
        function setZoom(zoom) {
            map.setZoom(zoom, {
                noAnimation: props.noAnimation
            });
        }
        // 设置地图类型
        function setMapType(mapType) {
            window[mapType] !== undefined && map.setMapType(window[mapType]);
        }
        function setHeading(heading) {
            map.setHeading(heading);
        }
        function setTilt(tilt) {
            map.setTilt(tilt);
        }
        // 设置地图是否可拖动
        function setDragging(enableDragging) {
            enableDragging ? map.enableDragging() : map.disableDragging();
        }
        // 设置地图惯性拖拽
        function setInertialDragging(enableInertialDragging) {
            enableInertialDragging ? map.enableInertialDragging() : map.disableInertialDragging();
        }
        // 设置地图是否可滚轮缩放
        function setScrollWheelZoom(enableScrollWheelZoom) {
            enableScrollWheelZoom ? map.enableScrollWheelZoom() : map.disableScrollWheelZoom();
        }
        // 设置地图是否可连续缩放
        function setContinuousZoom(enableContinuousZoom) {
            enableContinuousZoom ? map.enableContinuousZoom() : map.disableContinuousZoom();
        }
        // 设置地图是否可缩放至中心点
        function setResizeOnCenter(enableResizeOnCenter) {
            enableResizeOnCenter ? map.enableResizeOnCenter() : map.disableResizeOnCenter();
        }
        // 设置地图是否可双击缩放
        function setDoubleClickZoom(enableDoubleClickZoom) {
            enableDoubleClickZoom ? map.enableDoubleClickZoom() : map.disableDoubleClickZoom();
        }
        // 设置地图是否可键盘操作
        function setKeyboard(enableKeyboard) {
            enableKeyboard ? map.enableKeyboard() : map.disableKeyboard();
        }
        // 设置地图是否可手势缩放
        function setPinchToZoom(enablePinchToZoom) {
            enablePinchToZoom ? map.enablePinchToZoom() : map.disablePinchToZoom();
        }
        // 设置地图是否自动适应窗口大小
        function setAutoResize(enableAutoResize) {
            enableAutoResize ? map.enableAutoResize() : map.disableAutoResize();
        }
        onMounted(init);
        /**
         * 销毁地图，当使用 WebGL 渲染地图时，如果确认不再使用该地图实例，则需要
         * 调用本方法销毁 WebGL 上下文，否则频繁创建新地图实例会导致浏览器报：
         * too many WebGL context 的警告。
         */
        onUnmounted(() => {
            map === null || map === void 0 ? void 0 : map.destroy();
        });
        expose({
            // 父组件获取map实例方法
            getMapInstance: () => map,
            // 父组件/外部获取map组件 options
            getBaseMapOptions: () => props,
            // 重置地图中心
            resetCenter: () => setCenterAndZoom(props.center),
            // 设置地图是否可拖动
            setDragging
        });
        provide('getMapInstance', () => map);
        provide('parentUidGetter', uid);
        provide('baseMapSetCenterAndZoom', (_center) => setCenterAndZoom(_center));
        provide('baseMapSetDragging', (enableDragging) => setDragging(enableDragging));
        provide('getBaseMapOptions', () => props);
        return (_ctx, _cache) => {
            return (openBlock(), createElementBlock(Fragment, null, [
                createElementVNode("div", {
                    class: "baidu-map-container",
                    ref_key: "mapContainer",
                    ref: mapContainer,
                    style: normalizeStyle([{ width: unref(width), height: unref(height) }, { "background": "#f1f1f1", "position": "relative", "overflow": "hidden" }])
                }, [
                    renderSlot(_ctx.$slots, "loading", {}, () => [
                        createElementVNode("div", _hoisted_1$3, toDisplayString(!unref(initd) ? 'map loading...' : ''), 1)
                    ])
                ], 4),
                renderSlot(_ctx.$slots, "default")
            ], 64));
        };
    } }));

function useBaseMapEffect(cal) {
    var _a;
    const { on, off } = useBaseMapListener();
    const getMapInstance = inject('getMapInstance');
    const parentUidGetter = inject('parentUidGetter');
    const uid = parentUidGetter || ((_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.uid);
    const map = getMapInstance && getMapInstance();
    const eventKey = `__initd__${uid}`;
    let onUnmountedCallback;
    const _cal = ({ map }) => {
        onUnmountedCallback = cal(map);
    };
    if (map) {
        _cal({ map });
    }
    else {
        on(eventKey, _cal);
    }
    onUnmounted(() => {
        off(eventKey, _cal);
        onUnmountedCallback && onUnmountedCallback();
    });
}

const _hoisted_1$2 = { style: { "display": "none" } };
const __default__$k = {
    name: 'BControl',
    inheritAttrs: false
};
var script$k = /*#__PURE__*/ defineComponent(Object.assign(Object.assign({}, __default__$k), { props: {
        anchor: { default: 'BMAP_ANCHOR_TOP_LEFT' },
        offset: { default: () => ({ x: 83, y: 18 }) }
    }, emits: ['initd', 'unload'], setup(__props) {
        const props = __props;
        const controlContainer = ref();
        const { ready } = useLifeCycle();
        onMounted(() => {
            useBaseMapEffect((map) => {
                if (!controlContainer.value)
                    return;
                const customControl = new BMapGL.Control();
                customControl.defaultAnchor = window[props.anchor];
                customControl.defaultOffset = new BMapGL.Size(props.offset.x, props.offset.y);
                customControl.initialize = (_map) => {
                    return _map.getContainer().appendChild(controlContainer.value);
                };
                map.addControl(customControl);
                ready(map, customControl);
                return () => map.removeControl(customControl);
            });
        });
        return (_ctx, _cache) => {
            return (openBlock(), createElementBlock("div", _hoisted_1$2, [
                createElementVNode("div", mergeProps({
                    ref_key: "controlContainer",
                    ref: controlContainer
                }, _ctx.$attrs), [
                    renderSlot(_ctx.$slots, "default")
                ], 16)
            ]));
        };
    } }));

const __default__$j = {
    name: 'BScale'
};
var script$j = /*#__PURE__*/ defineComponent(Object.assign(Object.assign({}, __default__$j), { props: {
        anchor: { default: 'BMAP_ANCHOR_BOTTOM_LEFT' },
        offset: { default: () => ({ x: 83, y: 18 }) },
        unit: { default: 'BMAP_UNIT_METRIC' }
    }, emits: ['initd', 'unload'], setup(__props) {
        const props = __props;
        const { ready } = useLifeCycle();
        let scaleCtrl;
        useBaseMapEffect((map) => {
            scaleCtrl = new BMapGL.ScaleControl({
                offset: new BMapGL.Size(props.offset.x, props.offset.y),
                anchor: window[props.anchor]
            });
            setUnit();
            map.addControl(scaleCtrl);
            ready(map, scaleCtrl);
            return () => map.removeControl(scaleCtrl);
        });
        // 监听比例尺单位变化
        watch(() => props.unit, setUnit);
        /**
         * 设置比例尺单位制
         */
        function setUnit() {
            scaleCtrl.setUnit(window[props.unit]);
        }
        return (_ctx, _cache) => {
            return null;
        };
    } }));

const __default__$i = {
    name: 'BZoom'
};
var script$i = /*#__PURE__*/ defineComponent(Object.assign(Object.assign({}, __default__$i), { props: {
        anchor: { default: 'BMAP_ANCHOR_BOTTOM_RIGHT' },
        offset: { default: () => ({ x: 83, y: 18 }) }
    }, emits: ['initd', 'unload'], setup(__props) {
        const props = __props;
        const { ready } = useLifeCycle();
        let zoomControl;
        useBaseMapEffect((map) => {
            zoomControl = new BMapGL.ZoomControl({
                offset: new BMapGL.Size(props.offset.x, props.offset.y),
                anchor: window[props.anchor]
            });
            map.addControl(zoomControl);
            ready(map, zoomControl);
            return () => map.removeControl(zoomControl);
        });
        return (_ctx, _cache) => {
            return null;
        };
    } }));

const __default__$h = {
    name: 'BCityList'
};
var script$h = /*#__PURE__*/ defineComponent(Object.assign(Object.assign({}, __default__$h), { props: {
        anchor: { default: 'BMAP_ANCHOR_TOP_LEFT' },
        offset: { default: () => ({ x: 18, y: 18 }) },
        expand: { type: Boolean, default: false }
    }, emits: ['initd', 'unload'], setup(__props) {
        const props = __props;
        const { ready } = useLifeCycle();
        let cityListControl;
        useBaseMapEffect((map) => {
            cityListControl = new BMapGL.CityListControl({
                expand: props.expand,
                offset: new BMapGL.Size(props.offset.x, props.offset.y),
                anchor: window[props.anchor]
            });
            map.addControl(cityListControl);
            ready(map, cityListControl);
            return () => map.removeControl(cityListControl);
        });
        return (_ctx, _cache) => {
            return null;
        };
    } }));

const __default__$g = {
    name: 'BLocation'
};
var script$g = /*#__PURE__*/ defineComponent(Object.assign(Object.assign({}, __default__$g), { props: {
        anchor: { default: 'BMAP_ANCHOR_BOTTOM_RIGHT' },
        offset: { default: () => ({ x: 18, y: 18 }) },
        onLocationError: null,
        onLocationSuccess: null
    }, emits: ['initd', 'unload', 'locationSuccess', 'locationError'], setup(__props, { emit: vueEmits }) {
        const props = __props;
        const { ready } = useLifeCycle();
        let locationControl;
        useBaseMapEffect((map) => {
            locationControl = new BMapGL.LocationControl({
                offset: new BMapGL.Size(props.offset.x, props.offset.y),
                anchor: window[props.anchor]
            });
            map.addControl(locationControl);
            ready(map, locationControl);
            bindEvents(props, vueEmits, locationControl);
            return () => map.removeControl(locationControl);
        });
        return (_ctx, _cache) => {
            return null;
        };
    } }));

const copyrightControlPosCacheMap = {};

const _hoisted_1$1 = { style: { "display": "none" } };
const __default__$f = {
    name: 'BCopyright',
    inheritAttrs: false
};
var script$f = /*#__PURE__*/ defineComponent(Object.assign(Object.assign({}, __default__$f), { props: {
        anchor: { default: 'BMAP_ANCHOR_BOTTOM_RIGHT' },
        offset: { default: () => ({ x: 83, y: 18 }) }
    }, emits: ['initd', 'unload'], setup(__props) {
        var _a;
        const props = __props;
        const { ready } = useLifeCycle();
        const copyrightContainer = ref();
        let copyrightControl;
        const uid = (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.uid;
        onMounted(() => {
            const { anchor, offset } = props;
            useBaseMapEffect((map) => {
                if (!copyrightContainer.value)
                    return;
                let mapBounds = map.getBounds();
                // 同一位置的 copyright 应该调用 addCopyright,防止多个 copyright 重叠
                if (!(copyrightControl = copyrightControlPosCacheMap[anchor])) {
                    copyrightControl = new BMapGL.CopyrightControl({
                        offset: new BMapGL.Size(offset.x, offset.y),
                        anchor: window[anchor]
                    });
                    copyrightControlPosCacheMap[anchor] = copyrightControl;
                    map.addControl(copyrightControl);
                }
                copyrightControl.addCopyright({
                    id: uid,
                    content: copyrightContainer.value.innerHTML,
                    bounds: mapBounds
                });
                ready(map, copyrightControl);
                return () => {
                    var _a, _b;
                    const cacheCopyright = copyrightControlPosCacheMap[anchor];
                    const getCopyrightCollection = (_a = cacheCopyright === null || cacheCopyright === void 0 ? void 0 : cacheCopyright.getCopyrightCollection) === null || _a === void 0 ? void 0 : _a.bind(cacheCopyright);
                    if (getCopyrightCollection && ((_b = getCopyrightCollection()) === null || _b === void 0 ? void 0 : _b.length) > 1) {
                        cacheCopyright.removeCopyright(uid);
                    }
                    else {
                        map.removeControl(cacheCopyright);
                        Reflect.deleteProperty(copyrightControlPosCacheMap, anchor);
                    }
                };
            });
        });
        onUpdated(() => {
            var _a, _b;
            if (!copyrightControl)
                return;
            let copyright = copyrightControl === null || copyrightControl === void 0 ? void 0 : copyrightControl.getCopyright(uid);
            if ((copyright === null || copyright === void 0 ? void 0 : copyright.content) !== ((_a = copyrightContainer.value) === null || _a === void 0 ? void 0 : _a.innerHTML)) {
                copyrightControl.addCopyright({
                    id: uid,
                    content: (_b = copyrightContainer.value) === null || _b === void 0 ? void 0 : _b.innerHTML,
                    bounds: copyright.bounds
                });
            }
        });
        return (_ctx, _cache) => {
            return (openBlock(), createElementBlock("div", _hoisted_1$1, [
                createElementVNode("div", mergeProps({
                    ref_key: "copyrightContainer",
                    ref: copyrightContainer
                }, _ctx.$attrs), [
                    renderSlot(_ctx.$slots, "default")
                ], 16)
            ]));
        };
    } }));

const __default__$e = {
    name: 'BNavigation3d'
};
var script$e = /*#__PURE__*/ defineComponent(Object.assign(Object.assign({}, __default__$e), { props: {
        anchor: { default: 'BMAP_ANCHOR_BOTTOM_RIGHT' },
        offset: { default: () => ({ x: 83, y: 18 }) }
    }, emits: ['initd', 'unload'], setup(__props) {
        const props = __props;
        const { ready } = useLifeCycle();
        let navigation3dControl;
        useBaseMapEffect((map) => {
            navigation3dControl = new BMapGL.NavigationControl3D({
                offset: new BMapGL.Size(props.offset.x, props.offset.y),
                anchor: window[props.anchor]
            });
            map.addControl(navigation3dControl);
            ready(map, navigation3dControl);
            return () => map.removeControl(navigation3dControl);
        });
        return (_ctx, _cache) => {
            return null;
        };
    } }));

const __default__$d = {
    name: 'BPanoramaControl'
};
var script$d = /*#__PURE__*/ defineComponent(Object.assign(Object.assign({}, __default__$d), { props: {
        anchor: { default: 'BMAP_ANCHOR_TOP_RIGHT' },
        offset: { default: () => ({ x: 10, y: 10 }) }
    }, emits: ['initd', 'unload'], setup(__props) {
        const props = __props;
        const { ready } = useLifeCycle();
        let panoramaControl;
        useBaseMapEffect((map) => {
            panoramaControl = new BMapGL.PanoramaControl();
            panoramaControl.setOffset(new BMapGL.Size(props.offset.x, props.offset.y));
            panoramaControl.setAnchor(window[props.anchor]);
            map.addControl(panoramaControl);
            ready(map, panoramaControl);
            return () => map.removeControl(panoramaControl);
        });
        return (_ctx, _cache) => {
            return null;
        };
    } }));

const __default__$c = {
    name: 'BPanoramaCoverageLayer'
};
var script$c = /*#__PURE__*/ defineComponent(Object.assign(Object.assign({}, __default__$c), { emits: ['initd', 'unload'], setup(__props) {
        const { ready } = useLifeCycle();
        let panoramaCoverageLayer;
        useBaseMapEffect((map) => {
            panoramaCoverageLayer = new BMapGL.PanoramaCoverageLayer();
            map.addTileLayer(panoramaCoverageLayer);
            ready(map, panoramaCoverageLayer);
            return () => map.removeTileLayer(panoramaCoverageLayer);
        });
        return (_ctx, _cache) => {
            return null;
        };
    } }));

let icons = null;
function useDefaultMarkerIcons() {
    if (icons !== null)
        return icons;
    const defaultIconUrl = '//mapopen.bj.bcebos.com/cms/react-bmap/markers_new2x_fbb9e99.png';
    icons = {
        simple_red: new BMapGL.Icon(defaultIconUrl, new BMapGL.Size(42 / 2, 66 / 2), {
            imageOffset: new BMapGL.Size(454 / 2, 378 / 2),
            imageSize: new BMapGL.Size(600 / 2, 600 / 2)
        }),
        simple_blue: new BMapGL.Icon(defaultIconUrl, new BMapGL.Size(42 / 2, 66 / 2), {
            imageOffset: new BMapGL.Size(454 / 2, 450 / 2),
            imageSize: new BMapGL.Size(600 / 2, 600 / 2)
        }),
        loc_red: new BMapGL.Icon(defaultIconUrl, new BMapGL.Size(46 / 2, 70 / 2), {
            imageOffset: new BMapGL.Size(400 / 2, 378 / 2),
            imageSize: new BMapGL.Size(600 / 2, 600 / 2)
        }),
        loc_blue: new BMapGL.Icon(defaultIconUrl, new BMapGL.Size(46 / 2, 70 / 2), {
            imageOffset: new BMapGL.Size(400 / 2, 450 / 2),
            imageSize: new BMapGL.Size(600 / 2, 600 / 2)
        }),
        start: new BMapGL.Icon(defaultIconUrl, new BMapGL.Size(50 / 2, 80 / 2), {
            imageOffset: new BMapGL.Size(400 / 2, 278 / 2),
            imageSize: new BMapGL.Size(600 / 2, 600 / 2)
        }),
        end: new BMapGL.Icon(defaultIconUrl, new BMapGL.Size(50 / 2, 80 / 2), {
            imageOffset: new BMapGL.Size(450 / 2, 278 / 2),
            imageSize: new BMapGL.Size(600 / 2, 600 / 2)
        }),
        location: new BMapGL.Icon(defaultIconUrl, new BMapGL.Size(28 / 2, 40 / 2), {
            imageOffset: new BMapGL.Size(248 / 2, 466 / 2),
            imageSize: new BMapGL.Size(600 / 2, 600 / 2)
        })
    };
    for (let i = 1; i <= 10; i++) {
        icons['red' + i] = new BMapGL.Icon(defaultIconUrl, new BMapGL.Size(42 / 2, 66 / 2), {
            imageOffset: new BMapGL.Size((42 / 2) * (i - 1), 0),
            imageSize: new BMapGL.Size(600 / 2, 600 / 2)
        });
    }
    for (let i = 1; i <= 10; i++) {
        icons['blue' + i] = new BMapGL.Icon(defaultIconUrl, new BMapGL.Size(42 / 2, 66 / 2), {
            imageOffset: new BMapGL.Size((42 / 2) * (i - 1), 132 / 2),
            imageSize: new BMapGL.Size(600 / 2, 600 / 2)
        });
    }
    return icons;
}

const __default__$b = {
    name: 'BMarker'
};
var script$b = /*#__PURE__*/ defineComponent(Object.assign(Object.assign({}, __default__$b), { props: {
        position: null,
        offset: { default: () => ({
                x: 0,
                y: 0
            }) },
        icon: null,
        zIndex: null,
        enableMassClear: { type: Boolean, default: true },
        enableDragging: { type: Boolean, default: false },
        enableClicking: { type: Boolean, default: true },
        raiseOnDrag: { type: Boolean, default: false },
        draggingCursor: { default: 'pointer' },
        rotation: { default: 0 },
        title: { default: '' },
        onClick: null,
        onDblclick: null,
        onMousedown: null,
        onMouseup: null,
        onMouseout: null,
        onMouseover: null,
        onRemove: null,
        onInfowindowclose: null,
        onInfowindowopen: null,
        onDragstart: null,
        onDragging: null,
        onDragend: null,
        onRightClick: null
    }, emits: [
        'initd',
        'unload',
        'click',
        'dblclick',
        'mousedown',
        'mouseup',
        'mouseout',
        'mouseover',
        'remove',
        'infowindowclose',
        'infowindowopen',
        'dragstart',
        'dragging',
        'dragend',
        'rightclick'
    ], setup(__props, { emit: vueEmits }) {
        const props = __props;
        const { ready } = useLifeCycle();
        let marker;
        useBaseMapEffect((map) => {
            const cal = () => {
                marker && map.removeOverlay(marker);
            };
            const init = () => {
                if (!props.position)
                    return;
                const { position, offset, enableMassClear, enableDragging, enableClicking, raiseOnDrag, draggingCursor, rotation, title, icon, zIndex } = props;
                const options = {
                    offset: new BMapGL.Size(offset.x, offset.y),
                    enableMassClear,
                    enableDragging,
                    enableClicking,
                    raiseOnDrag,
                    draggingCursor,
                    title
                };
                if (icon) {
                    options.icon = getIconConfig();
                }
                marker = new BMapGL.Marker(new BMapGL.Point(position.lng, position.lat), options);
                setRotation(rotation);
                isDef(zIndex) && setZIndex(zIndex);
                // 在地图上添加点标记
                map.addOverlay(marker);
                bindEvents(props, vueEmits, marker);
                ready(map, marker);
            };
            init();
            // 监听值变化
            watch(() => props.position, callWhenDifferentValue((n) => {
                marker ? setPosition(n) : init();
            }), { deep: true });
            watch(() => props.icon, callWhenDifferentValue(setIcon), { deep: true });
            watch(() => props.offset, callWhenDifferentValue(setOffset), { deep: true });
            watch(() => props.enableDragging, setDragging);
            watch(() => props.enableMassClear, setMassClear);
            watch(() => props.rotation, setRotation);
            return cal;
        });
        provide('getOverlayInstance', () => marker);
        // 获取图标配置
        function getIconConfig() {
            const defaultIcons = useDefaultMarkerIcons();
            const { icon } = props;
            if (isString(icon) && defaultIcons[icon]) {
                return defaultIcons[icon];
            }
            else {
                // @ts-ignore
                const { anchor, imageOffset, imageSize, imageUrl, printImageUrl } = icon;
                const iconOptions = {
                    imageSize: new BMapGL.Size(imageSize.width, imageSize.height)
                };
                if (anchor) {
                    iconOptions.anchor = new BMapGL.Size(anchor.x, anchor.y);
                }
                if (imageOffset) {
                    iconOptions.imageOffset = new BMapGL.Size(imageOffset.x, imageOffset.y);
                }
                if (printImageUrl) {
                    iconOptions.printImageUrl = printImageUrl;
                }
                return new BMapGL.Icon(imageUrl, new BMapGL.Size(imageSize.width, imageSize.height), iconOptions);
            }
        }
        function setZIndex(zIndex) {
            marker.setZIndex(zIndex);
        }
        function setPosition(position) {
            position && position.lat && position.lng && marker.setPosition(new BMapGL.Point(position.lng, position.lat));
        }
        function setIcon() {
            marker.setIcon(getIconConfig());
        }
        function setDragging(enableDragging) {
            enableDragging ? marker.enableDragging() : marker.disableDragging();
        }
        function setMassClear(enableMassClear) {
            enableMassClear ? marker.enableMassClear() : marker.disableMassClear();
        }
        function setOffset(offset) {
            marker.setOffset(new BMapGL.Size(offset.x, offset.y));
        }
        function setRotation(rotation) {
            marker.setRotation(rotation);
        }
        return (_ctx, _cache) => {
            return null;
        };
    } }));

const __default__$a = {
    name: 'BMarker3d'
};
var script$a = /*#__PURE__*/ defineComponent(Object.assign(Object.assign({}, __default__$a), { props: {
        position: null,
        height: null,
        size: { default: 50 },
        shape: { default: 'BMAP_SHAPE_CIRCLE' },
        fillColor: { default: '#f00' },
        fillOpacity: { default: 0.8 },
        icon: null,
        enableMassClear: { type: Boolean, default: true },
        onClick: null,
        onDblclick: null,
        onMousedown: null,
        onMouseup: null,
        onMouseout: null,
        onMouseover: null,
        onRemove: null,
        onRightClick: null
    }, emits: [
        'initd',
        'unload',
        'click',
        'dblclick',
        'mousedown',
        'mouseup',
        'mouseout',
        'mouseover',
        'remove',
        'rightclick'
    ], setup(__props, { emit: vueEmits }) {
        const props = __props;
        const { ready } = useLifeCycle();
        let marker3d;
        useBaseMapEffect((map) => {
            const cal = () => {
                map.removeOverlay(marker3d);
            };
            const init = () => {
                if (!props.position || !props.height)
                    return;
                const { position, shape, fillColor, fillOpacity, size, icon, height, enableMassClear } = props;
                const options = {
                    size,
                    fillColor,
                    fillOpacity,
                    shape: window[shape]
                };
                if (icon) {
                    options.icon = getIconConfig();
                }
                marker3d = new BMapGL.Marker3D(new BMapGL.Point(position.lng, position.lat), height, options);
                // 在地图上添加点标记
                map.addOverlay(marker3d);
                setMassClear(enableMassClear);
                bindEvents(props, vueEmits, marker3d);
                ready(map, marker3d);
            };
            init();
            // 监听值变化
            watch(() => props.position, callWhenDifferentValue((n) => {
                marker3d ? setPosition(n) : init();
            }), { deep: true });
            watch(() => props.height, (n) => {
                marker3d ? setHeight(n) : init();
            });
            watch(() => props.enableMassClear, setMassClear);
            watch(() => props.icon, callWhenDifferentValue(setIcon), { deep: true });
            watch(() => props.enableMassClear, setMassClear);
            watch(() => props.fillOpacity, setFillOpacity);
            watch(() => props.fillColor, setFillColor);
            return cal;
        });
        provide('getOverlayInstance', () => marker3d);
        // 获取图标配置
        function getIconConfig() {
            const { icon } = props;
            // @ts-ignore
            const { anchor, imageOffset, imageSize, imageUrl, printImageUrl } = icon;
            const iconOptions = {
                imageSize: new BMapGL.Size(imageSize.width, imageSize.height)
            };
            if (anchor) {
                iconOptions.anchor = new BMapGL.Size(anchor.x, anchor.y);
            }
            if (imageOffset) {
                iconOptions.imageOffset = new BMapGL.Size(imageOffset.x, imageOffset.y);
            }
            if (printImageUrl) {
                iconOptions.printImageUrl = printImageUrl;
            }
            return new BMapGL.Icon(imageUrl, new BMapGL.Size(imageSize.width, imageSize.height), iconOptions);
        }
        function setPosition(position) {
            try {
                // FIXME: 更新 position baidu-map-gl api报错: TypeError: Cannot read properties of undefined (reading '2x')
                marker3d.setPosition(new BMapGL.Point(position.lng, position.lat));
            }
            catch (error) {
                console.error(error);
            }
        }
        function setHeight(height) {
            marker3d.setHeight(height);
        }
        function setFillColor(color) {
            marker3d.setFillColor(color);
        }
        function setFillOpacity(opacity) {
            marker3d.setFillOpacity(opacity);
        }
        function setIcon() {
            marker3d.setIcon(getIconConfig());
        }
        function setMassClear(enableMassClear) {
            enableMassClear ? marker3d.enableMassClear() : marker3d.disableMassClear();
        }
        return (_ctx, _cache) => {
            return null;
        };
    } }));

const __default__$9 = {
    name: 'BLabel'
};
var script$9 = /*#__PURE__*/ defineComponent(Object.assign(Object.assign({}, __default__$9), { props: {
        content: null,
        position: null,
        offset: { default: () => ({
                x: 0,
                y: 0
            }) },
        style: null,
        enableMassClear: { type: Boolean, default: true },
        onClick: null,
        onDblclick: null,
        onMousedown: null,
        onMouseup: null,
        onMouseout: null,
        onMouseover: null,
        onRemove: null,
        onRightclick: null
    }, emits: [
        'initd',
        'unload',
        'click',
        'dblclick',
        'mousedown',
        'mouseup',
        'mouseout',
        'mouseover',
        'remove',
        'rightclick'
    ], setup(__props, { emit: vueEmits }) {
        const props = __props;
        const { ready } = useLifeCycle();
        let label;
        useBaseMapEffect((map) => {
            const cal = () => {
                label && map.removeOverlay(label);
            };
            const init = () => {
                const { content, position, offset, enableMassClear, style } = props;
                const options = {
                    position: new BMapGL.Point(position.lng, position.lat),
                    offset: new BMapGL.Size(offset.x, offset.y),
                    enableMassClear
                };
                label = new BMapGL.Label(content, options);
                // 自定义文本标注样式
                if (style) {
                    label.setStyle(style);
                }
                map.addOverlay(label);
                // isDef(zIndex) && setZIndex(zIndex)
                bindEvents(props, vueEmits, label);
            };
            init();
            ready(map, label);
            // 监听值变化
            watch(() => props.position, callWhenDifferentValue(setPosition), { deep: true });
            watch(() => props.offset, callWhenDifferentValue(setOffset), { deep: true });
            watch(() => props.style, callWhenDifferentValue(setStyle), { deep: true });
            watch(() => props.content, setContent);
            watch(() => props.enableMassClear, setMassClear);
            return cal;
        });
        provide('getOverlayInstance', () => label);
        // function setZIndex(zIndex: number) {
        //   console.log('shezhi ')
        //   label.setZIndex(zIndex)
        // }
        function setPosition(position) {
            label.setPosition(new BMapGL.Point(position.lng, position.lat));
        }
        function setStyle(styles) {
            if (isDef(styles))
                label.setStyle(styles);
        }
        function setContent(content) {
            label.setContent(content);
        }
        function setOffset(offset) {
            label.setOffset(new BMapGL.Size(offset.x, offset.y));
        }
        function setMassClear(enableMassClear) {
            enableMassClear ? label.enableMassClear() : label.disableMassClear();
        }
        return (_ctx, _cache) => {
            return null;
        };
    } }));

const __default__$8 = {
    name: 'BPolyline'
};
var script$8 = /*#__PURE__*/ defineComponent(Object.assign(Object.assign({}, __default__$8), { props: {
        path: null,
        strokeColor: { default: '#000' },
        strokeWeight: { default: 2 },
        strokeOpacity: { default: 1 },
        strokeStyle: { default: 'solid' },
        enableMassClear: { type: Boolean, default: true },
        enableEditing: { type: Boolean, default: false },
        enableClicking: { type: Boolean, default: true },
        geodesic: { type: Boolean, default: false },
        clip: { type: Boolean, default: true },
        onClick: null,
        onDblclick: null,
        onMousedown: null,
        onMouseup: null,
        onMouseout: null,
        onMouseover: null,
        onRemove: null,
        onLineupdate: null
    }, emits: [
        'initd',
        'unload',
        'click',
        'dblclick',
        'mousedown',
        'mouseup',
        'mouseout',
        'mouseover',
        'remove',
        'lineupdate'
    ], setup(__props, { emit: vueEmits }) {
        const props = __props;
        const { ready } = useLifeCycle();
        let polyline;
        useBaseMapEffect((map) => {
            const cal = () => {
                map.removeOverlay(polyline);
            };
            const init = () => {
                if (!props.path || !props.path.length)
                    return;
                const { path, strokeColor, strokeWeight, strokeOpacity, strokeStyle, enableMassClear, enableEditing, enableClicking, geodesic, clip } = props;
                const pathPoints = pathPointsToMapPoints(path);
                polyline = new BMapGL.Polyline(pathPoints, {
                    strokeColor,
                    strokeWeight,
                    strokeOpacity,
                    strokeStyle,
                    enableMassClear,
                    enableEditing,
                    enableClicking,
                    geodesic,
                    clip
                });
                map.addOverlay(polyline);
                bindEvents(props, vueEmits, polyline);
                ready(map, polyline);
            };
            init();
            // 监听值变化
            watch(() => props.path, callWhenDifferentValue((n) => {
                polyline ? setPath(n) : init();
            }), {
                deep: true
            });
            watch(() => props.strokeColor, setStrokeColor);
            watch(() => props.strokeOpacity, setStrokeOpacity);
            watch(() => props.strokeWeight, setStrokeWeight);
            watch(() => props.strokeStyle, setStrokeStyle);
            watch(() => props.enableMassClear, setMassClear);
            watch(() => props.enableEditing, setEditing);
            return cal;
        });
        provide('getOverlayInstance', () => polyline);
        function pathPointsToMapPoints(pathPoints) {
            return pathPoints.map(({ lng, lat }) => new BMapGL.Point(lng, lat));
        }
        function setPath(path) {
            polyline.setPath(pathPointsToMapPoints(path));
        }
        function setStrokeColor(color) {
            polyline.setStrokeColor(color);
        }
        function setStrokeOpacity(opacity) {
            polyline.setStrokeOpacity(opacity);
        }
        function setStrokeWeight(weight) {
            polyline.setStrokeWeight(weight);
        }
        function setStrokeStyle(style) {
            polyline.setStrokeStyle(style);
        }
        function setMassClear(enableMassClear) {
            enableMassClear ? polyline.enableMassClear() : polyline.disableMassClear();
        }
        function setEditing(enableEditing) {
            enableEditing ? polyline.enableEditing() : polyline.disableEditing();
        }
        return (_ctx, _cache) => {
            return null;
        };
    } }));

const __default__$7 = {
    name: 'BBezierCurve'
};
var script$7 = /*#__PURE__*/ defineComponent(Object.assign(Object.assign({}, __default__$7), { props: {
        path: null,
        controlPoints: null,
        strokeColor: { default: '#000' },
        strokeWeight: { default: 2 },
        strokeOpacity: { default: 1 },
        strokeStyle: { default: 'solid' },
        enableMassClear: { type: Boolean, default: true },
        onClick: null,
        onDblclick: null,
        onMousedown: null,
        onMouseup: null,
        onMouseout: null,
        onMouseover: null,
        onRemove: null,
        onLineupdate: null
    }, emits: [
        'initd',
        'unload',
        'click',
        'dblclick',
        'mousedown',
        'mouseup',
        'mouseout',
        'mouseover',
        'remove',
        'lineupdate'
    ], setup(__props, { emit: vueEmits }) {
        const props = __props;
        const { ready } = useLifeCycle();
        let bezierCurve;
        useBaseMapEffect((map) => {
            const cal = () => {
                map.removeOverlay(bezierCurve);
            };
            const init = () => {
                if (!props.path || !props.path.length || !props.controlPoints || !props.controlPoints.length)
                    return;
                const { path, controlPoints, strokeColor, strokeWeight, strokeOpacity, strokeStyle, enableMassClear } = props;
                const pathPoints = pathPointsToMapPoints(path);
                const _controlPoints = controlPoints.map((points) => {
                    return pathPointsToMapPoints(points);
                });
                try {
                    bezierCurve = new BMapGL.BezierCurve(pathPoints, _controlPoints, {
                        strokeColor,
                        strokeWeight,
                        strokeOpacity,
                        strokeStyle,
                        enableMassClear
                    });
                }
                catch (error) {
                    console.error('Init bezierCurve overlay error, make sure path and controlPoints data is correct!');
                }
                map.addOverlay(bezierCurve);
                ready(map, bezierCurve);
                bindEvents(props, vueEmits, bezierCurve);
            };
            init();
            // 监听值变化
            watch(() => props.path, callWhenDifferentValue((n) => {
                bezierCurve ? setPath(n) : init();
            }), {
                deep: true
            });
            watch(() => props.controlPoints, callWhenDifferentValue((n) => {
                bezierCurve ? setControlPoints(n) : init();
            }), {
                deep: true
            });
            watch(() => props.strokeColor, setStrokeColor);
            watch(() => props.strokeOpacity, setStrokeOpacity);
            watch(() => props.strokeWeight, setStrokeWeight);
            watch(() => props.strokeStyle, setStrokeStyle);
            watch(() => props.enableMassClear, setMassClear);
            return cal;
        });
        provide('getOverlayInstance', () => bezierCurve);
        function pathPointsToMapPoints(pathPoints) {
            return pathPoints.map(({ lng, lat }) => new BMapGL.Point(lng, lat));
        }
        function setPath(path) {
            bezierCurve.setPath(pathPointsToMapPoints(path));
        }
        function setControlPoints(points) {
            bezierCurve.setControlPoints(points.map((points) => pathPointsToMapPoints(points)));
        }
        function setStrokeColor(color) {
            bezierCurve.setStrokeColor(color);
        }
        function setStrokeOpacity(opacity) {
            bezierCurve.setStrokeOpacity(opacity);
        }
        function setStrokeWeight(weight) {
            bezierCurve.setStrokeWeight(weight);
        }
        function setStrokeStyle(style) {
            bezierCurve.setStrokeStyle(style);
        }
        function setMassClear(enableMassClear) {
            enableMassClear ? bezierCurve.enableMassClear() : bezierCurve.disableMassClear();
        }
        return (_ctx, _cache) => {
            return null;
        };
    } }));

const __default__$6 = {
    name: 'BPolygon'
};
var script$6 = /*#__PURE__*/ defineComponent(Object.assign(Object.assign({}, __default__$6), { props: {
        path: null,
        isBoundary: { type: Boolean },
        strokeColor: { default: '#000' },
        autoCenter: { type: Boolean, default: true },
        strokeWeight: { default: 2 },
        strokeOpacity: { default: 1 },
        strokeStyle: { default: 'solid' },
        fillColor: { default: '#fff' },
        fillOpacity: { default: 0.3 },
        enableMassClear: { type: Boolean },
        enableEditing: { type: Boolean },
        enableClicking: { type: Boolean },
        geodesic: { type: Boolean, default: false },
        clip: { type: Boolean, default: true },
        onClick: null,
        onDblclick: null,
        onMousedown: null,
        onMouseup: null,
        onMouseout: null,
        onMouseover: null,
        onRemove: null,
        onLineupdate: null
    }, emits: [
        'initd',
        'unload',
        'click',
        'dblclick',
        'mousedown',
        'mouseup',
        'mouseout',
        'mouseover',
        'remove',
        'lineupdate'
    ], setup(__props, { emit: vueEmits }) {
        const props = __props;
        const { ready } = useLifeCycle();
        const injectBaseMapSetCenterAndZoom = inject('baseMapSetCenterAndZoom');
        let polygon;
        useBaseMapEffect((map) => {
            const cal = () => {
                polygon && map.removeOverlay(polygon);
            };
            const init = () => {
                if (!props.path || !props.path.length)
                    return;
                const { path, strokeColor, strokeWeight, strokeOpacity, strokeStyle, fillOpacity, fillColor, enableMassClear, enableEditing, enableClicking, geodesic, clip, isBoundary } = props;
                const pathPoints = isBoundary ? path : pathPointsToMapPoints(path);
                if (!pathPoints)
                    return;
                polygon = new BMapGL.Polygon(pathPoints, {
                    strokeColor,
                    strokeWeight,
                    strokeOpacity,
                    strokeStyle,
                    fillOpacity,
                    fillColor,
                    enableMassClear,
                    enableEditing,
                    enableClicking,
                    geodesic,
                    clip
                });
                map.addOverlay(polygon);
                bindEvents(props, vueEmits, polygon);
                ready(map, polygon);
                syncMapCenter();
                watch(() => props.strokeColor, setStrokeColor);
                watch(() => props.strokeOpacity, setStrokeOpacity);
                watch(() => props.fillColor, setFillColor);
                watch(() => props.fillOpacity, setFillOpacity);
                watch(() => props.strokeWeight, setStrokeWeight);
                watch(() => props.strokeStyle, setStrokeStyle);
                watch(() => props.enableMassClear, setMassClear);
                watch(() => props.enableEditing, setEditing);
            };
            init();
            // 监听值变化, 初始为空时不会初始化, 不为空值时初始化
            watch(() => props.path, callWhenDifferentValue((path) => {
                polygon ? setPath(path) : init();
            }), {
                deep: true
            });
            return cal;
        });
        provide('getOverlayInstance', () => polygon);
        function syncMapCenter() {
            nextTick(() => {
                var _a;
                // 自动设置中心点
                if (props.autoCenter) {
                    // 获取中心点
                    try {
                        const center = (_a = polygon.getBounds()) === null || _a === void 0 ? void 0 : _a.getCenter();
                        injectBaseMapSetCenterAndZoom(center);
                    }
                    catch (e) {
                        console.warn('set center error', e);
                    }
                }
            });
        }
        function pathPointsToMapPoints(pathPoints) {
            return pathPoints.map(({ lng, lat }) => new BMapGL.Point(lng, lat));
        }
        function setPath(path) {
            if (props.isBoundary) {
                polygon.setPath(path);
            }
            else {
                polygon.setPath(pathPointsToMapPoints(path));
            }
            syncMapCenter();
        }
        function setStrokeColor(color) {
            polygon.setStrokeColor(color);
        }
        function setFillColor(color) {
            polygon.setFillColor(color);
        }
        function setStrokeOpacity(opacity) {
            polygon.setStrokeOpacity(opacity);
        }
        function setFillOpacity(opacity) {
            polygon.setFillOpacity(opacity);
        }
        function setStrokeWeight(weight) {
            polygon.setStrokeWeight(weight);
        }
        function setStrokeStyle(style) {
            polygon.setStrokeStyle(style);
        }
        function setMassClear(enableMassClear) {
            enableMassClear ? polygon.enableMassClear() : polygon.disableMassClear();
        }
        function setEditing(enableEditing) {
            enableEditing ? polygon.enableEditing() : polygon.disableEditing();
        }
        return (_ctx, _cache) => {
            return null;
        };
    } }));

const _hoisted_1 = { style: { "display": "none" } };
const __default__$5 = {
    name: 'BInfoWindow'
};
var script$5 = /*#__PURE__*/ defineComponent(Object.assign(Object.assign({}, __default__$5), { props: {
        modelValue: { type: Boolean, default: false },
        title: { default: '' },
        position: null,
        width: { default: 0 },
        height: { default: 0 },
        maxWidth: { default: 220 },
        offset: { default: () => ({
                x: 0,
                y: 0
            }) },
        enableAutoPan: { type: Boolean, default: true },
        enableCloseOnClick: { type: Boolean, default: true },
        onClose: null,
        onOpen: null,
        onMaximize: null,
        onRestore: null,
        onClickclose: null
    }, emits: [
        'initd',
        'unload',
        'close',
        'open',
        'maximize',
        'restore',
        'clickclose',
        'update:modelValue'
    ], setup(__props, { emit: vueEmits }) {
        const props = __props;
        const visible = computed({
            get() {
                return props.modelValue;
            },
            set(value) {
                vueEmits('update:modelValue', value);
            }
        });
        const infoWindowContainer = ref();
        const { ready } = useLifeCycle();
        let infoWindow;
        let _map;
        useBaseMapEffect((map) => {
            _map = map;
            const cal = () => {
                infoWindow && map.removeOverlay(infoWindow);
            };
            const init = () => {
                const { title, width, height, enableAutoPan, maxWidth, offset, enableCloseOnClick } = props;
                const options = {
                    width,
                    height,
                    title,
                    maxWidth,
                    enableAutoPan,
                    enableCloseOnClick,
                    offset: new BMapGL.Size(offset.x, offset.y)
                };
                infoWindow = new BMapGL.InfoWindow(infoWindowContainer.value || '', options);
                infoWindow.addEventListener('close', () => {
                    if (props.modelValue)
                        visible.value = false;
                });
                infoWindow.addEventListener('open', () => {
                    if (!props.modelValue)
                        visible.value = true;
                });
                map.addOverlay(infoWindow);
                redraw();
                bindObserver();
                bindEvents(props, vueEmits, infoWindow);
                ready(map, infoWindow);
                if (props.modelValue) {
                    // 多个 infoWindow, 显示最后一个实例, 其他实例同步显隐状态
                    nextTick(() => {
                        open();
                        nextTick(() => {
                            !infoWindow._visible && (visible.value = false);
                        });
                    });
                }
            };
            if (!infoWindowContainer.value) {
                nextTick(() => init());
            }
            else {
                init();
            }
            // 监听值变化
            watch(() => props.position, callWhenDifferentValue((res) => {
                console.log(res);
                setPosition(res);
            }), { deep: true });
            watch(() => props.offset, callWhenDifferentValue(setOffset), { deep: true });
            watch(() => props.title, setTitle);
            watch(() => props.width, setWidth);
            watch(() => props.height, setHeight);
            watch(() => props.maxWidth, setMaxWidth);
            watch(() => props.enableAutoPan, setAutoPan);
            watch(() => props.enableCloseOnClick, setCloseOnClick);
            watch(() => props.modelValue, callWhenDifferentValue(() => {
                props.modelValue ? open() : close();
            }));
            return cal;
        });
        onUpdated(() => {
            if (infoWindow && infoWindow.isOpen()) {
                setContent(infoWindowContainer.value || '');
                redraw();
            }
        });
        provide('getOverlayInstance', () => infoWindow);
        function bindObserver() {
            const MutationObserver = window.MutationObserver;
            if (!MutationObserver) {
                return;
            }
            new MutationObserver(() => {
                infoWindow.redraw();
            }).observe(infoWindowContainer.value, { attributes: true, childList: true, characterData: true, subtree: true });
        }
        function open() {
            const { position } = props;
            if (!position || !infoWindow)
                return;
            _map.openInfoWindow(infoWindow, new BMapGL.Point(position.lng, position.lat));
            visible.value = true;
        }
        function close() {
            if (!infoWindow)
                return;
            infoWindow.hide();
            visible.value = false;
        }
        function redraw() {
            var _a;
            infoWindow.redraw();
            Array.prototype.forEach.call(((_a = infoWindowContainer.value) === null || _a === void 0 ? void 0 : _a.querySelectorAll('img')) || [], (imgEl) => {
                imgEl.onload = () => {
                    infoWindow.redraw();
                };
            });
        }
        function setTitle(title) {
            infoWindow.setTitle(title);
        }
        function setHeight(height) {
            infoWindow.setHeight(height);
        }
        function setWidth(width) {
            infoWindow.setWidth(width);
        }
        function setMaxWidth(maxWidth) {
            infoWindow.setMaxWidth(maxWidth);
        }
        // function setMaximize(maximize: boolean) {
        // 	maximize ? infoWindow.enableMaximize() : infoWindow.disableMaximize()
        // }
        function setAutoPan(autoPan) {
            autoPan ? infoWindow.enableAutoPan() : infoWindow.disableAutoPan();
        }
        function setCloseOnClick(closeOnClick) {
            closeOnClick ? infoWindow.enableCloseOnClick() : infoWindow.disableCloseOnClick();
        }
        function setPosition(position) {
            close();
            infoWindow.setPosition(new BMapGL.Point(position.lng, position.lat));
            open();
        }
        function setContent(content) {
            infoWindow.setContent(content);
        }
        function setOffset(offset) {
            infoWindow.setOffset(new BMapGL.Size(offset.x, offset.y));
        }
        return (_ctx, _cache) => {
            return (openBlock(), createElementBlock("div", _hoisted_1, [
                createElementVNode("div", mergeProps({
                    ref_key: "infoWindowContainer",
                    ref: infoWindowContainer
                }, _ctx.$attrs), [
                    renderSlot(_ctx.$slots, "default")
                ], 16)
            ]));
        };
    } }));

const __default__$4 = {
    name: 'BCircle'
};
var script$4 = /*#__PURE__*/ defineComponent(Object.assign(Object.assign({}, __default__$4), { props: {
        center: null,
        radius: null,
        strokeColor: { default: '#000' },
        strokeOpacity: { default: 1 },
        fillColor: { default: '#fff' },
        fillOpacity: { default: 0.3 },
        strokeWeight: { default: 2 },
        strokeStyle: { default: 'solid' },
        enableMassClear: { type: Boolean, default: true },
        enableEditing: { type: Boolean, default: false },
        enableClicking: { type: Boolean, default: true },
        geodesic: { type: Boolean, default: false },
        clip: { type: Boolean, default: true },
        onClick: null,
        onDblclick: null,
        onMousedown: null,
        onMouseup: null,
        onMouseout: null,
        onMouseover: null,
        onRemove: null,
        onLineupdate: null
    }, emits: [
        'initd',
        'unload',
        'click',
        'dblclick',
        'mousedown',
        'mouseup',
        'mouseout',
        'mouseover',
        'remove',
        'lineupdate'
    ], setup(__props, { emit: vueEmits }) {
        const props = __props;
        const { ready } = useLifeCycle();
        let circle;
        useBaseMapEffect((map) => {
            const cal = () => {
                map.removeOverlay(circle);
            };
            const init = () => {
                const { center, radius, strokeColor, strokeOpacity, fillColor, fillOpacity, strokeWeight, strokeStyle, enableMassClear, enableEditing, enableClicking, geodesic, clip } = props;
                const centerPoint = new BMapGL.Point(center.lng, center.lat);
                circle = new BMapGL.Circle(centerPoint, radius, {
                    strokeColor,
                    strokeWeight,
                    strokeOpacity,
                    strokeStyle,
                    enableMassClear,
                    enableEditing,
                    enableClicking,
                    geodesic,
                    clip,
                    fillOpacity,
                    fillColor
                });
                map.addOverlay(circle);
                bindEvents(props, vueEmits, circle);
                ready(map, circle);
            };
            init();
            // 监听值变化
            watch(() => props.center, callWhenDifferentValue(setCenter), { deep: true });
            watch(() => props.radius, setRadius);
            watch(() => props.strokeColor, setStrokeColor);
            watch(() => props.strokeOpacity, setStrokeOpacity);
            watch(() => props.fillColor, setFillColor);
            watch(() => props.fillOpacity, setFillOpacity);
            watch(() => props.strokeWeight, setStrokeWeight);
            watch(() => props.strokeStyle, setStrokeStyle);
            watch(() => props.enableMassClear, setMassClear);
            watch(() => props.enableEditing, setEditing);
            return cal;
        });
        provide('getOverlayInstance', () => circle);
        function setRadius(radius) {
            circle.setRadius(radius);
        }
        function setCenter(center) {
            if (circle) {
                circle.setCenter(new BMapGL.Point(center.lng, center.lat));
            }
        }
        function setStrokeColor(color) {
            circle.setStrokeColor(color);
        }
        function setFillColor(color) {
            circle.setFillColor(color);
        }
        function setStrokeOpacity(opacity) {
            circle.setStrokeOpacity(opacity);
        }
        function setFillOpacity(opacity) {
            circle.setFillOpacity(opacity);
        }
        function setStrokeWeight(weight) {
            circle.setStrokeWeight(weight);
        }
        function setStrokeStyle(style) {
            circle.setStrokeStyle(style);
        }
        function setMassClear(enableMassClear) {
            enableMassClear ? circle.enableMassClear() : circle.disableMassClear();
        }
        function setEditing(enableEditing) {
            enableEditing ? circle.enableEditing() : circle.disableEditing();
        }
        return (_ctx, _cache) => {
            return null;
        };
    } }));

const __default__$3 = {
    name: 'BPrism'
};
var script$3 = /*#__PURE__*/ defineComponent(Object.assign(Object.assign({}, __default__$3), { props: {
        path: null,
        altitude: null,
        isBoundary: { type: Boolean },
        topFillColor: { default: '#fff' },
        topFillOpacity: { default: 0.5 },
        sideFillColor: { default: '#fff' },
        sideFillOpacity: { default: 0.8 },
        autoCenter: { type: Boolean, default: true },
        enableMassClear: { type: Boolean, default: true },
        onClick: null,
        onDblclick: null,
        onMousedown: null,
        onMouseup: null,
        onMouseout: null,
        onMouseover: null,
        onRemove: null,
        onLineupdate: null
    }, emits: [
        'initd',
        'unload',
        'click',
        'dblclick',
        'mousedown',
        'mouseup',
        'mouseout',
        'mouseover',
        'remove',
        'lineupdate'
    ], setup(__props, { emit: vueEmits }) {
        const props = __props;
        const { ready } = useLifeCycle();
        const injectBaseMapSetCenterAndZoom = inject('baseMapSetCenterAndZoom');
        let prism;
        useBaseMapEffect((map) => {
            const cal = () => {
                prism && map.removeOverlay(prism);
            };
            const init = () => {
                if (!props.path || !props.path.length)
                    return;
                const { path, altitude, isBoundary, topFillColor, topFillOpacity, sideFillColor, sideFillOpacity, enableMassClear } = props;
                const pathPoints = isBoundary ? path : pathPointsToMapPoints(path);
                if (!pathPoints)
                    return;
                prism = new BMapGL.Prism(pathPoints, altitude, {
                    topFillColor,
                    topFillOpacity,
                    sideFillColor,
                    sideFillOpacity,
                    enableMassClear
                });
                map.addOverlay(prism);
                bindEvents(props, vueEmits, prism);
                ready(map, prism);
                syncMapCenter();
                watch(() => props.enableMassClear, setMassClear);
                watch(() => props.topFillColor, setTopFillColor);
                watch(() => props.topFillOpacity, setTopFillOpacity);
                watch(() => props.sideFillColor, setSideFillColor);
                watch(() => props.sideFillOpacity, setSideFillOpacity);
                watch(() => props.altitude, setAltitude);
            };
            init();
            // 监听值变化, 初始为空时不会初始化, 不为空值时初始化
            watch(() => props.path, callWhenDifferentValue(() => {
                prism
                    ? () => {
                        cal();
                        init();
                    }
                    : init();
            }), {
                deep: true
            });
            return cal;
        });
        provide('getOverlayInstance', () => prism);
        function syncMapCenter() {
            if (props.autoCenter) {
                nextTick(() => {
                    var _a;
                    // 自动设置中心点
                    // 获取中心点
                    try {
                        const center = (_a = prism.getBounds()) === null || _a === void 0 ? void 0 : _a.getCenter();
                        injectBaseMapSetCenterAndZoom(center);
                    }
                    catch (e) {
                        console.warn('set center error', e);
                    }
                });
            }
        }
        function pathPointsToMapPoints(pathPoints) {
            return pathPoints.map(({ lng, lat }) => new BMapGL.Point(lng, lat));
        }
        function setMassClear(enableMassClear) {
            enableMassClear ? prism.enableMassClear() : prism.disableMassClear();
        }
        function setTopFillColor(color) {
            prism.setTopFillColor(color);
        }
        function setTopFillOpacity(opacity) {
            prism.setTopFillOpacity(opacity);
        }
        function setSideFillColor(color) {
            prism.setSideFillColor(color);
        }
        function setSideFillOpacity(opacity) {
            prism.setSideFillOpacity(opacity);
        }
        function setAltitude(altitude) {
            prism.setAltitude(altitude);
        }
        return (_ctx, _cache) => {
            return null;
        };
    } }));

const __default__$2 = {
    name: 'BGroundOverlay'
};
var script$2 = /*#__PURE__*/ defineComponent(Object.assign(Object.assign({}, __default__$2), { props: {
        type: null,
        url: null,
        startPoint: null,
        endPoint: null,
        autoCenter: { type: Boolean, default: false },
        opacity: { default: 1 },
        onClick: null,
        onDblclick: null,
        onMousemove: null,
        onMouseover: null,
        onMouseout: null
    }, emits: ['initd', 'unload', 'click', 'dblclick', 'mousemove', 'mouseover', 'mouseout'], setup(__props, { emit: vueEmits }) {
        const props = __props;
        const { ready } = useLifeCycle();
        let groundOverlay;
        useBaseMapEffect((map) => {
            const cal = () => {
                groundOverlay && map.removeOverlay(groundOverlay);
            };
            const init = () => {
                cal();
                let { startPoint, endPoint, opacity, type, autoCenter } = props;
                const url = getUrl();
                if (!url || !startPoint || !endPoint)
                    return;
                const boundsObj = getBounds(startPoint, endPoint);
                const options = {
                    opacity,
                    type,
                    url: url.value || url
                };
                groundOverlay = new BMapGL.GroundOverlay(boundsObj, options);
                map.addOverlay(groundOverlay);
                // 自动设置中心点
                if (autoCenter) {
                    nextTick(() => {
                        // 获取中心点
                        try {
                            const center = boundsObj.getCenter();
                            map.panTo(center);
                        }
                        catch (e) {
                            error('set center error');
                        }
                    });
                }
            };
            init();
            bindEvents(props, vueEmits, groundOverlay);
            ready(map, groundOverlay);
            watch(() => props, callWhenDifferentValue(init), { deep: true });
            return cal;
        });
        function getBounds(start, end) {
            return new BMapGL.Bounds(new BMapGL.Point(start.lng, end.lat), new BMapGL.Point(end.lng, start.lat));
        }
        function getUrl() {
            let url = props.url;
            if (typeof url === 'function') {
                url = url();
                if (!url && process.env.NODE_ENV === 'development') {
                    error(`expect a function return string or canvas html element, but got ${url}`);
                    return;
                }
            }
            return url;
        }
        return (_ctx, _cache) => {
            return null;
        };
    } }));

const __default__$1 = {
    name: 'BContextMenu'
};
var script$1 = /*#__PURE__*/ defineComponent(Object.assign(Object.assign({}, __default__$1), { props: {
        width: { default: 100 },
        menuItems: { default: () => [] },
        onOpen: null,
        onClose: null
    }, emits: ['initd', 'unload', 'open', 'close'], setup(__props, { emit: vueEmits }) {
        const props = __props;
        // const getParentInstance = inject('getOverlayInstance', () => null)
        const { ready } = useLifeCycle();
        let contextMenu;
        useBaseMapEffect((map) => {
            // const target = getParentInstance() || map
            const target = map;
            const cal = () => {
                contextMenu && target.removeContextMenu(contextMenu);
            };
            const init = () => {
                const { width, menuItems } = props;
                contextMenu = new BMapGL.ContextMenu();
                for (const item of menuItems) {
                    if (isString(item) && item === '-') {
                        contextMenu.addSeparator();
                        continue;
                    }
                    const menuItem = new BMapGL.MenuItem(item.text, function (point, pixel) {
                        item.callback.call(null, {
                            point,
                            pixel,
                            map,
                            BMapGL,
                            target: target
                        });
                    }, {
                        width,
                        id: String(Math.random())
                    });
                    item.disabled ? menuItem.disable() : menuItem.enable();
                    contextMenu.addItem(menuItem);
                }
                target.addContextMenu(contextMenu);
                bindEvents(props, vueEmits, contextMenu);
            };
            watch(() => {
                return props.menuItems;
            }, callWhenDifferentValue(() => {
                cal();
                init();
            }), {
                deep: true
            });
            init();
            ready(map, contextMenu);
            // 在地图上添加点标记
            return cal;
        });
        return (_ctx, _cache) => {
            return null;
        };
    } }));

const __default__ = {
    name: 'BDistrictLayer'
};
var script = /*#__PURE__*/ defineComponent(Object.assign(Object.assign({}, __default__), { props: {
        name: null,
        kind: { default: 0 },
        fillColor: { default: '#fdfd27' },
        fillOpacity: { default: 1 },
        strokeColor: { default: '#231cf8' },
        viewport: { type: Boolean, default: false },
        onClick: null,
        onDblclick: null,
        onRightclick: null,
        onRightdblclick: null,
        onMousemove: null,
        onMouseover: null,
        onMouseout: null
    }, emits: ['initd', 'unload', 'mouseover', 'mouseout', 'click'], setup(__props, { emit: vueEmits }) {
        const props = __props;
        const { ready } = useLifeCycle();
        let districtLayer;
        useBaseMapEffect((map) => {
            if (!props.name)
                return warn('DistrictLayer props.name is required');
            const { name, kind, fillColor, fillOpacity, strokeColor, viewport } = props;
            districtLayer = new BMapGL.DistrictLayer({
                name: `(${name})`,
                kind,
                fillColor,
                fillOpacity,
                strokeColor,
                viewport
            });
            map.addDistrictLayer(districtLayer);
            bindEvents(props, vueEmits, districtLayer);
            ready(map, districtLayer);
            return () => map.removeDistrictLayer(districtLayer);
        });
        return (_ctx, _cache) => {
            return null;
        };
    } }));

var componentsList = [
    script$l,
    script$k,
    script$j,
    script$i,
    script$e,
    script$b,
    script$a,
    script$f,
    script$g,
    script$9,
    script$8,
    script$6,
    script$7,
    script$4,
    script$h,
    script$3,
    script$5,
    script$1,
    script$d,
    script$c,
    script$2,
    script
];

/**
 * 获取地图区域边界
 * @param cal 获取成功后的回调函数
 * @returns { isLoading, boundaries, get }
 */
function useAreaBoundary(cal) {
    const isLoading = ref(false);
    const boundaries = ref([]);
    let boundaryInstance;
    const getFn = (area) => {
        if (!boundaryInstance) {
            boundaryInstance = new BMapGL.Boundary();
        }
        isLoading.value = true;
        boundaryInstance.get(area, (rs) => {
            isLoading.value = false;
            boundaries.value = rs.boundaries;
            cal && cal(boundaries);
        });
    };
    onUnmounted(() => {
        // 手动回收内存
        boundaryInstance = null;
    });
    return {
        /**
         * 是否加载中
         */
        isLoading,
        /**
         * 区域边界数据
         */
        boundaries,
        /**
         * 获取指定区域边界
         * @param {string} area 区域名
         * @example get('北京市')
         */
        get: getFn
    };
}

const statusMap$1 = {
    1: 'PLAYING',
    2: 'INITIAL',
    3: 'STOPPING'
};
/**
 * 轨迹动画
 * @param {any} map 地图组件实例引用
 * @param {UseTrackAnimationOptions} options 轨迹动画配置
 * @returns { setPath, start, stop}
 */
function useTrackAnimation(map, options) {
    let instance;
    let pl;
    let mapComponentInstance;
    let mapInstance;
    const status = ref('INITIAL');
    options = options || {};
    watch(() => map.value, (n) => {
        mapComponentInstance = n;
    });
    const init = () => {
        if (!instance) {
            mapInstance = mapComponentInstance.getMapInstance();
            instance = new BMapGLLib.TrackAnimation(mapInstance, pl, options);
        }
    };
    const setPath = (path) => {
        const point = path.map((pathItem) => new BMapGL.Point(pathItem.lng, pathItem.lat));
        pl = new BMapGL.Polyline(point);
        init();
    };
    const start = () => {
        if (instance && status.value === 'INITIAL') {
            instance.start();
            syncState();
            setTimeout(() => {
                instance._viewAni.addEventListener('animationend', syncState);
            });
        }
    };
    const cancel = () => {
        if (instance) {
            instance.cancel();
            syncState();
        }
    };
    const stop = () => {
        if (instance) {
            instance.pause();
            syncState();
        }
    };
    const proceed = () => {
        if (instance) {
            instance.continue();
            syncState();
        }
    };
    const syncState = () => {
        setTimeout(() => {
            if (instance) {
                status.value = statusMap$1[instance._status];
            }
        });
    };
    onUnmounted(() => {
        if (instance && status.value !== 'INITIAL') {
            instance.cancel();
        }
        // 手动回收内存
        if (mapInstance) {
            mapInstance.removeOverlay(pl);
            pl = null;
        }
    });
    return {
        /**
         * 设置路径动画路径
         */
        setPath,
        /**
         * 开始动画
         */
        start,
        /**
         * 暂停动画
         */
        stop,
        /**
         * 取消动画
         */
        cancel,
        /**
         * 继续播放动画
         */
        proceed,
        /**
         * 动画状态
         */
        status
    };
}

/**
 * 获取一个地图经纬度点实例
 */
function usePoint() {
    const point = ref(null);
    const genPoint = ({ lng, lat }) => {
        point.value = new BMapGL.Point(lng, lat);
    };
    return {
        /**
         * BMapGL.Point 实例
         */
        point,
        /**
         * 设置实例点坐标
         */
        set: genPoint
    };
}

// FIXME: 取消动画后再次开始动画, 地图上 pio 不消失, 可能是地图本身 bug
function useViewAnimation(map, options) {
    options = options || {};
    options.disableDragging = options.disableDragging !== undefined ? false : true;
    const status = ref('INITIAL');
    // 保存未初始化前的事件监听
    const eventListener = {
        animationcancel: [() => (status.value = 'INITIAL')],
        animationend: [() => (status.value = 'INITIAL')],
        animationstart: [() => (status.value = 'PLAYING')]
    };
    let mapComponentInstance;
    let mapInstance;
    let initd = false;
    watch(() => map.value, (n) => {
        mapComponentInstance = n;
    });
    const syncDragging = () => {
        const { enableDragging } = mapComponentInstance.getBaseMapOptions();
        mapComponentInstance.setDragging(enableDragging);
    };
    const defaultValue = {
        addEventListener(event, cal) {
            if (!eventListener[event]) {
                eventListener[event] = [];
            }
            eventListener[event].push(cal);
        },
        removeEventListener(event, cal) {
            const subs = eventListener[event];
            if (subs) {
                if (!cal) {
                    eventListener[event] = [];
                }
                else {
                    for (let i = subs.length; i >= 0; i--) {
                        if (subs[i] === cal) {
                            subs.splice(i, 1);
                        }
                    }
                }
            }
        }
    };
    let viewAnimation = defaultValue;
    const createViewAnimation = (keyFrames) => {
        const { loop, duration, delay } = options;
        for (const keyFrame of keyFrames) {
            if (keyFrame.center) {
                const { lng, lat } = keyFrame.center;
                keyFrame.center = new BMapGL.Point(lng, lat);
            }
        }
        viewAnimation = new BMapGL.ViewAnimation(keyFrames, {
            duration,
            delay,
            interation: loop
        });
        for (const eventKey of Object.keys(eventListener)) {
            const events = eventListener[eventKey];
            if (events && events.length) {
                events.forEach((cal) => {
                    viewAnimation.addEventListener(eventKey, cal);
                });
            }
        }
        initd = true;
    };
    const start = () => {
        if (initd && status.value !== 'PLAYING') {
            mapInstance = mapComponentInstance.getMapInstance();
            mapInstance.startViewAnimation(viewAnimation);
            mapComponentInstance.setDragging(!options.disableDragging);
        }
    };
    const cancel = () => {
        if (initd && status.value !== 'INITIAL') {
            viewAnimation._cancel(mapInstance);
            syncDragging();
        }
    };
    const stop = () => {
        if (initd && status.value === 'PLAYING') {
            viewAnimation._pause();
            status.value = 'STOPPING';
        }
    };
    const proceed = () => {
        if (initd && status.value === 'STOPPING') {
            viewAnimation._continue();
            status.value = 'PLAYING';
        }
    };
    onUnmounted(() => {
        try {
            if (viewAnimation && status.value == 'INITIAL') {
                mapInstance = mapComponentInstance.getMapInstance();
                viewAnimation._cancel(mapInstance);
                syncDragging();
            }
        }
        catch (e) {
            return false;
        }
    });
    return {
        viewAnimation,
        start,
        cancel,
        stop,
        proceed,
        status,
        setKeyFrames: createViewAnimation
    };
}

/**
 * ip定位
 */
function useIpLocation(cal) {
    const location = ref({});
    const isLoading = ref(true);
    const init = () => {
        isLoading.value = true;
        new BMapGL.LocalCity().get((res) => {
            isLoading.value = false;
            location.value = {
                code: res.code,
                point: res.center,
                name: res.name
            };
            cal && cal(location);
        });
    };
    return {
        location,
        isLoading,
        get: init
    };
}

const statusMap = {
    // 定位成功
    0: 'BMAP_STATUS_SUCCESS',
    // 定位超时
    8: 'ERR_POSITION_TIMEOUT',
    // 定位不可用
    2: 'ERR_POSITION_UNAVAILABLE',
    // 没有权限，定位被拒绝
    6: 'ERR_PERMISSION_DENIED'
};
function useBrowserLocation(options, cal) {
    options = options || {};
    const location = ref({});
    const isLoading = ref(true);
    const isError = ref(false);
    const status = ref();
    const init = () => {
        options.SDKLocation = options.enableSDKLocation;
        new Promise((resolve, reject) => {
            isLoading.value = true;
            const geolocation = new BMapGL.Geolocation();
            geolocation.getCurrentPosition(function (res) {
                const _status = geolocation.getStatus();
                status.value = statusMap[_status];
                if (_status === window['BMAP_STATUS_SUCCESS']) {
                    const { address, accuracy, point } = res;
                    resolve({
                        accuracy,
                        point,
                        address
                    });
                }
                else {
                    reject();
                }
            }, options);
        })
            .then((res) => {
            isError.value = false;
            location.value = res;
            cal && cal(location);
        })
            .catch(() => {
            isError.value = true;
        })
            .finally(() => {
            isLoading.value = false;
        });
    };
    return {
        get: init,
        isLoading,
        isError,
        status,
        location
    };
}

/**
 * 由地址解析坐标点
 */
function useAddressGeocoder(cal) {
    const point = ref();
    const isLoading = ref(true);
    const isEmpty = ref(true);
    let geocoder;
    const init = () => {
        if (!geocoder) {
            geocoder = new BMapGL.Geocoder();
        }
    };
    const get = (address, city) => {
        init();
        if (!address)
            return error('missed required params: address');
        if (!city)
            return error('missed required  params: city');
        const isBatch = isArray(address);
        isLoading.value = true;
        (() => {
            if (isBatch) {
                return Promise.all(address.map((item) => getPoint(geocoder, item, city)));
            }
            return getPoint(geocoder, address, city);
        })()
            .then((res) => {
            if (res) {
                if (isBatch) {
                    let emptyCount = 0;
                    point.value = res.map((item) => {
                        emptyCount += +!item;
                        return item;
                    });
                    isEmpty.value = emptyCount === res.length;
                }
                else {
                    point.value = res;
                    isEmpty.value = false;
                }
            }
            else {
                point.value = res;
                isEmpty.value = true;
            }
            cal && cal(point);
        })
            .catch((err) => {
            error(err);
            isEmpty.value = true;
            point.value = null;
        })
            .finally(() => {
            isLoading.value = false;
        });
    };
    return {
        get,
        point,
        isLoading,
        isEmpty
    };
}
function getPoint(geocoder, address, city) {
    return new Promise((resolve) => {
        // 将地址解析结果显示在地图上，并调整地图视野
        geocoder.getPoint(address, (_point) => {
            if (_point) {
                resolve(_point);
            }
            else {
                resolve(null);
            }
        }, city);
    });
}

/**
 * 由地址解析坐标点
 */
function usePointGeocoder(options, cal) {
    options = options || {};
    const result = ref();
    const isLoading = ref(true);
    const isEmpty = ref(true);
    let geocoder;
    const init = (point) => {
        if (!point)
            return error('missed required params: point');
        if (!geocoder) {
            geocoder = new BMapGL.Geocoder();
        }
        const isBatch = isArray(point);
        isLoading.value = true;
        (() => {
            if (isBatch) {
                return Promise.all(point.map((item) => getAddress(geocoder, item, options)));
            }
            return getAddress(geocoder, point, options);
        })()
            .then((res) => {
            if (res) {
                if (isBatch) {
                    let emptyCount = 0;
                    result.value = res.map((item) => {
                        emptyCount += +!item;
                        return item;
                    });
                    isEmpty.value = emptyCount === res.length;
                }
                else {
                    result.value = res;
                    isEmpty.value = false;
                }
            }
            else {
                result.value = res;
                isEmpty.value = true;
            }
            cal && cal(result);
        })
            .catch(() => {
            isEmpty.value = true;
            result.value = undefined;
        })
            .finally(() => {
            isLoading.value = false;
        });
    };
    return {
        get: init,
        result,
        isLoading,
        isEmpty
    };
}
function getAddress(geocoder, point, options) {
    return new Promise((resolve) => {
        geocoder.getLocation(new BMapGL.Point(point.lng, point.lat), (res) => {
            if (res)
                resolve(res);
            else
                resolve(null);
        }, options);
    });
}

var CoordinatesFromType;
(function (CoordinatesFromType) {
    /**
     *  WGS84坐标（GPS标准坐标）
     */
    CoordinatesFromType[CoordinatesFromType["COORDINATES_WGS84"] = 1] = "COORDINATES_WGS84";
    /**
     *  WGS84的平面墨卡托坐标（搜狗地图坐标）
     */
    CoordinatesFromType[CoordinatesFromType["COORDINATES_WGS84_MC"] = 2] = "COORDINATES_WGS84_MC";
    /**
     * GCJ02坐标(火星坐标)，即高德地图、腾讯地图、谷歌坐标和MapABC等地图使用的坐标；
     */
    CoordinatesFromType[CoordinatesFromType["COORDINATES_GCJ02"] = 3] = "COORDINATES_GCJ02";
    /**
     *  GCJ02的平面墨卡托坐标（火星坐标对应的墨卡托平面坐标）
     */
    CoordinatesFromType[CoordinatesFromType["COORDINATES_GCJ02_MC"] = 4] = "COORDINATES_GCJ02_MC";
    /**
     *  百度地图采用的经纬度坐标（bd09ll）
     */
    CoordinatesFromType[CoordinatesFromType["COORDINATES_BD09"] = 5] = "COORDINATES_BD09";
    /**
     * 百度地图采用的墨卡托平面坐标（bd09mc）
     */
    CoordinatesFromType[CoordinatesFromType["COORDINATES_BD09_MC"] = 6] = "COORDINATES_BD09_MC";
    /**
     * 图吧地图坐标
     */
    CoordinatesFromType[CoordinatesFromType["COORDINATES_MAPBAR"] = 7] = "COORDINATES_MAPBAR";
    /**
     * 51地图坐标
     */
    CoordinatesFromType[CoordinatesFromType["COORDINATES_51"] = 8] = "COORDINATES_51";
})(CoordinatesFromType || (CoordinatesFromType = {}));
var CoordinatesToType;
(function (CoordinatesToType) {
    /**
     * GCJ02坐标(火星坐标)，即高德地图、腾讯地图、谷歌坐标和MapABC等地图使用的坐标；
     */
    CoordinatesToType[CoordinatesToType["COORDINATES_GCJ02"] = 3] = "COORDINATES_GCJ02";
    /**
     * 百度地图采用的经纬度坐标（bd09ll）
     */
    CoordinatesToType[CoordinatesToType["COORDINATES_BD09"] = 5] = "COORDINATES_BD09";
    /**
     * 百度地图采用的墨卡托平面坐标（bd09mc）
     */
    CoordinatesToType[CoordinatesToType["COORDINATES_BD09_MC"] = 6] = "COORDINATES_BD09_MC";
})(CoordinatesToType || (CoordinatesToType = {}));
function usePointConvertor() {
    const result = ref();
    const isLoading = ref(true);
    const isError = ref(false);
    const status = ref();
    let convertor;
    const init = (points, from, to) => {
        if (!points)
            return error('missed required params: points');
        if (!from)
            return error('missed required params: from');
        if (!to)
            return error('missed required params: to');
        if (!points.length)
            return;
        if (!convertor) {
            convertor = new BMapGL.Convertor();
        }
        isLoading.value = true;
        const pointsInstance = points.map((item) => new BMapGL.Point(item.lng, item.lat));
        getConvertor(convertor, pointsInstance, from, to)
            .then((res) => {
            result.value = res.points.map((item) => ({ lng: item.lng, lat: item.lat }));
            status.value = res.status;
            isError.value = false;
        })
            .catch((status) => {
            status.value = status;
            isError.value = true;
        })
            .finally(() => {
            isLoading.value = false;
        });
    };
    return {
        convert: init,
        result,
        isLoading,
        isError,
        status
    };
}
function getConvertor(convertor, point, from, to) {
    return new Promise((resolve, reject) => {
        convertor.translate(point, from, to, (res) => {
            if (res.status === 0)
                resolve(res);
            else
                reject(res.status);
        });
    });
}

// // global register
const vue3BaiduMapGl = {
    install: (app, options) => {
        const { ak, plugins: p, pluginsSourceLink: psl } = options || {};
        const appProp = app.config.globalProperties;
        for (const component of componentsList) {
            const name = component.name;
            app.component(name, component);
        }
        ak && (appProp.$baiduMapAk = ak);
        p && (appProp.$baiduMapPlugins = p);
        psl && (appProp.$baiduMapPluginsSourceLink = psl);
    },
    version: '2.0.1'
};
// for umd
const install = vue3BaiduMapGl.install;
const version = vue3BaiduMapGl.version;

export { script$7 as BBezierCurve, script$4 as BCircle, script$h as BCityList, script$1 as BContextMenu, script$k as BControl, script$f as BCopyright, script as BDistrictLayer, script$2 as BGroundOverlay, script$5 as BInfoWindow, script$9 as BLabel, script$g as BLocation, script$l as BMap, script$b as BMarker, script$a as BMarker3d, script$e as BNavigation3d, script$d as BPanoramaControl, script$c as BPanoramaCoverageLayer, script$6 as BPolygon, script$8 as BPolyline, script$3 as BPrism, script$j as BScale, script$i as BZoom, CoordinatesFromType, CoordinatesToType, DistrictType, vue3BaiduMapGl as default, install, useAddressGeocoder, useAreaBoundary, useBrowserLocation, useDefaultMarkerIcons, useIpLocation, usePoint, usePointConvertor, usePointGeocoder, useTrackAnimation, useViewAnimation, version };
